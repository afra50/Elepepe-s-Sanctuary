const db = require("../config/db");
const RequestModel = require("../models/requestModel");
const ProjectModel = require("../models/projectModel");
const sharp = require("sharp");
const { v4: uuidv4 } = require("uuid");
const path = require("path");
const fs = require("fs").promises;
const Joi = require("joi");

// --- 1. Validation Schemas ---

// Schema for public request creation (existing)
const requestSchema = Joi.object({
  applicantType: Joi.string()
    .valid("person", "organization", "vetClinic")
    .required(),
  fullName: Joi.string().min(2).max(100).required(),
  email: Joi.string().email().max(100).required(),
  phone: Joi.string().max(20).required(),
  country: Joi.string().max(100).required(),
  city: Joi.string().max(100).allow(null, ""),
  species: Joi.string().valid("rat", "guineaPig", "other").required(),
  speciesOther: Joi.string().max(100).allow(null, ""),
  animalName: Joi.string().max(100).required(),
  age: Joi.string().max(50).allow(null, ""),
  animalsCount: Joi.number().integer().min(1).max(99).default(1),
  description: Joi.string().min(20).max(8000).required(),
  amount: Joi.number().positive().max(1000000).required(),
  currency: Joi.string().valid("EUR", "PLN").required(),
  amountType: Joi.string().valid("estimated", "exact").required(),
  deadline: Joi.date().greater("now").required(),
  treatmentOngoing: Joi.string().valid("true", "false").default("false"),
  needsInstallments: Joi.string().valid("true", "false").default("false"),
  otherFundraiserLink: Joi.string().uri().max(500).allow(null, ""),
  otherHelp: Joi.string().max(1000).allow(null, ""),
  payoutName: Joi.string().max(100).required(),
  payoutIban: Joi.string().max(50).required(),
  payoutBankName: Joi.string().max(100).required(),
  payoutBankCountry: Joi.string().max(100).required(),
  payoutSwift: Joi.string().max(20).required(),
  payoutAddress: Joi.string().max(255).required(),
  consentDataProcessing: Joi.string().valid("true").required(),
  consentTruth: Joi.string().valid("true").required(),
  consentPublicStory: Joi.string().valid("true").required(),
  submissionLanguage: Joi.string().valid("pl", "en", "es").required(),
}).unknown(true);

// Schema for ADMIN project creation (NEW)
// We validate the structure of projectData sent from the modal
const projectDataSchema = Joi.object({
  // Basic Data
  applicantType: Joi.string()
    .valid("person", "organization", "vetClinic")
    .required(),
  fullName: Joi.string().min(2).max(100).required(),
  animalName: Joi.string().required(),
  species: Joi.string().valid("rat", "guineaPig", "other").required(),
  animalsCount: Joi.number().integer().min(1).required(),
  city: Joi.string().allow(null, ""),

  // Config
  slug: Joi.string().required(), // Admin must provide a slug (auto-generated by front)
  status: Joi.string().valid("draft", "active").required(),
  isUrgent: Joi.boolean().default(false),

  // Content (Translations) - expecting objects {pl, en, es}
  title: Joi.object({
    pl: Joi.string().allow(""),
    en: Joi.string().allow(""),
    es: Joi.string().allow(""),
  }).required(),
  description: Joi.object({
    pl: Joi.string().allow(""),
    en: Joi.string().allow(""),
    es: Joi.string().allow(""),
  }).required(),
  country: Joi.object({
    pl: Joi.string().allow(""),
    en: Joi.string().allow(""),
    es: Joi.string().allow(""),
  }).required(),
  age: Joi.object({
    pl: Joi.string().allow(""),
    en: Joi.string().allow(""),
    es: Joi.string().allow(""),
  }).required(),
  speciesOther: Joi.object({
    pl: Joi.string().allow(""),
    en: Joi.string().allow(""),
    es: Joi.string().allow(""),
  }).allow(null),

  // Finance
  amountTarget: Joi.number().positive().required(),
  amountCollected: Joi.number().min(0).default(0),
  currency: Joi.string().valid("EUR", "PLN").required(),
  deadline: Joi.string().required(), // Date string YYYY-MM-DD

  // Files meta
  selectedFileIds: Joi.array().items(Joi.number()).default([]),
  coverSelection: Joi.object({
    type: Joi.string().valid("existing", "new"),
    id: Joi.alternatives().try(Joi.number(), Joi.string()),
  }).allow(null),
}).unknown(true);

// --- HANDLERS ---

const createRequest = async (req, res) => {
  const { error, value } = requestSchema.validate(req.body, {
    abortEarly: false,
  });
  if (error) {
    return res.status(400).json({
      error: "Validation error",
      details: error.details.map((d) => d.message),
    });
  }

  const connection = await db.getConnection();
  try {
    await connection.beginTransaction();

    const requestData = {
      applicantType: value.applicantType,
      submissionLanguage: value.submissionLanguage,
      fullName: value.fullName,
      email: value.email,
      phone: value.phone,
      country: value.country,
      city: value.city || null,
      species: value.species,
      speciesOther: value.speciesOther || null,
      animalName: value.animalName,
      age: value.age || null,
      animalsCount: value.animalsCount,
      description: value.description,
      amount: value.amount,
      currency: value.currency,
      amountType: value.amountType,
      deadline: value.deadline,
      treatmentOngoing: value.treatmentOngoing === "true" ? 1 : 0,
      needsInstallments: value.needsInstallments === "true" ? 1 : 0,
      otherFundraiserLink: value.otherFundraiserLink || null,
      otherHelp: value.otherHelp || null,
      payoutName: value.payoutName,
      payoutIban: value.payoutIban,
      payoutBankName: value.payoutBankName,
      payoutBankCountry: value.payoutBankCountry,
      payoutSwift: value.payoutSwift,
      payoutAddress: value.payoutAddress,
      consentDataProcessing: 1,
      consentTruth: 1,
      consentPublicStory: 1,
    };

    const newRequestId = await RequestModel.createRequest(
      connection,
      requestData
    );

    if (req.files) {
      const allFiles = [
        ...(req.files.petPhotos || []),
        ...(req.files.documents || []),
      ];
      if (allFiles.length > 20) throw new Error("Too many files.");

      const baseUploadDir = path.join(
        __dirname,
        "..",
        "uploads",
        "requests",
        String(newRequestId)
      );
      const photosDir = path.join(baseUploadDir, "photos");
      const docsDir = path.join(baseUploadDir, "documents");
      await fs.mkdir(photosDir, { recursive: true });
      await fs.mkdir(docsDir, { recursive: true });

      const filesToInsert = [];
      for (const file of allFiles) {
        if (file.size > 10 * 1024 * 1024) continue;
        let filename = `${uuidv4()}`;
        let targetDir = file.fieldname === "petPhotos" ? photosDir : docsDir;
        let fileType = file.fieldname === "petPhotos" ? "photo" : "document";
        let folderName =
          file.fieldname === "petPhotos" ? "photos" : "documents";
        let finalFilename;

        if (file.mimetype.startsWith("image/")) {
          finalFilename = `${filename}.webp`;
          await sharp(file.buffer)
            .resize({ width: 1200, withoutEnlargement: true })
            .webp({ quality: 80 })
            .toFile(path.join(targetDir, finalFilename));
        } else {
          finalFilename = `${filename}${path.extname(file.originalname)}`;
          await fs.writeFile(path.join(targetDir, finalFilename), file.buffer);
        }
        filesToInsert.push([
          newRequestId,
          `/uploads/requests/${newRequestId}/${folderName}/${finalFilename}`,
          fileType,
          file.originalname,
        ]);
      }
      if (filesToInsert.length > 0)
        await RequestModel.addFiles(connection, filesToInsert);
    }

    await connection.commit();
    res.status(201).json({
      message: "Request submitted successfully",
      requestId: newRequestId,
    });
  } catch (error) {
    await connection.rollback();
    console.error("Error creating request:", error);
    res.status(500).json({
      error: "Internal Server Error",
      message: "Failed to save the request.",
    });
  } finally {
    connection.release();
  }
};

const getRequests = async (req, res) => {
  const connection = await db.getConnection();
  try {
    const { status } = req.query;
    const filters = status ? { status } : {};
    const requests = await RequestModel.getRequests(connection, filters);
    res.status(200).json(requests);
  } catch (error) {
    res.status(500).json({ error: "Internal Server Error" });
  } finally {
    connection.release();
  }
};

const getRequestDetails = async (req, res) => {
  const connection = await db.getConnection();
  try {
    const { id } = req.params;
    const requestRaw = await RequestModel.getRequestById(connection, id);
    if (!requestRaw)
      return res.status(404).json({ message: "Request not found" });

    const files = await RequestModel.getFilesByRequestId(connection, id);
    const baseUrl = `${req.protocol}://${req.get("host")}`;
    const formatFile = (f) => ({
      id: f.id,
      url: `${baseUrl}${f.file_path}`,
      originalName: f.original_name,
      type: f.file_type,
    });

    const requestData = {
      id: requestRaw.id,
      status: requestRaw.status,
      createdAt: requestRaw.created_at,
      applicantType: requestRaw.applicant_type,
      fullName: requestRaw.full_name,
      email: requestRaw.email,
      phone: requestRaw.phone,
      country: requestRaw.country,
      city: requestRaw.city,
      species: requestRaw.species,
      speciesOther: requestRaw.species_other,
      animalName: requestRaw.animal_name,
      age: requestRaw.age,
      animalsCount: requestRaw.animals_count,
      description: requestRaw.description,
      amount: requestRaw.amount,
      currency: requestRaw.currency,
      amountType: requestRaw.amount_type,
      deadline: requestRaw.deadline,
      treatmentOngoing: requestRaw.treatment_ongoing,
      needsInstallments: requestRaw.needs_installments,
      otherFundraiserLink: requestRaw.other_fundraiser_link,
      otherHelp: requestRaw.other_help,
      payoutName: requestRaw.payout_name,
      payoutIban: requestRaw.payout_iban,
      payoutBankName: requestRaw.payout_bank_name,
      payoutBankCountry: requestRaw.payout_bank_country,
      payoutSwift: requestRaw.payout_swift,
      payoutAddress: requestRaw.payout_address,
      submissionLanguage: requestRaw.submission_language,
      petPhotos: files.filter((f) => f.file_type === "photo").map(formatFile),
      documents: files
        .filter((f) => f.file_type === "document")
        .map(formatFile),
    };
    res.status(200).json(requestData);
  } catch (error) {
    res.status(500).json({ error: "Server Error" });
  } finally {
    connection.release();
  }
};

const updateRequestStatus = async (req, res) => {
  const connection = await db.getConnection();
  const { id } = req.params;
  const status = req.body.status;

  // 1. Parsowanie projectData
  let projectData = {};
  if (req.body.projectData) {
    try {
      projectData = JSON.parse(req.body.projectData);
    } catch (e) {
      connection.release();
      return res
        .status(400)
        .json({ code: "INVALID_JSON", message: "Invalid projectData JSON" });
    }
  }

  // 2. Walidacja statusu (bez zmian)
  const allowedStatuses = ["pending", "approved", "rejected"];
  if (!status || !allowedStatuses.includes(status)) {
    connection.release();
    return res
      .status(400)
      .json({ code: "INVALID_STATUS", message: "Invalid status" });
  }

  try {
    await connection.beginTransaction();
    const requestData = await RequestModel.getRequestById(connection, id);
    if (!requestData) {
      await connection.rollback();
      return res
        .status(404)
        .json({ code: "REQUEST_NOT_FOUND", message: "Request not found" });
    }

    // === CREATE PROJECT LOGIC ===
    if (status === "approved" && requestData.status !== "approved") {
      // 3. Walidacja danych projektu (Joi)
      const { error: projectError, value: validatedProject } =
        projectDataSchema.validate(projectData, { abortEarly: false });

      if (projectError) {
        await connection.rollback();
        return res.status(400).json({
          code: "VALIDATION_ERROR",
          message: "Project data invalid",
          details: projectError.details.map((d) => d.message),
        });
      }

      // 4. Tworzenie Projektu (bez zmian)
      const newProjectData = {
        requestId: requestData.id,
        applicantType: validatedProject.applicantType,
        fullName: validatedProject.fullName,
        animalName: validatedProject.animalName,
        animalsCount: validatedProject.animalsCount,
        species: validatedProject.species,
        city: validatedProject.city,
        amountTarget: validatedProject.amountTarget,
        currency: validatedProject.currency,
        deadline: validatedProject.deadline,
        slug: validatedProject.slug,
        status: validatedProject.status,
        isUrgent: validatedProject.isUrgent ? 1 : 0,
        title: JSON.stringify(validatedProject.title),
        description: JSON.stringify(validatedProject.description),
        country: JSON.stringify(validatedProject.country),
        age: JSON.stringify(validatedProject.age),
        speciesOther: validatedProject.speciesOther
          ? JSON.stringify(validatedProject.speciesOther)
          : null,
      };

      const newProjectId = await ProjectModel.createProject(
        connection,
        newProjectData
      );

      // --- OBSŁUGA PLIKÓW ---
      const filesToInsert = [];
      let coverSet = false;

      // ==================================================
      // A. STARE PLIKI (Z Requesta) - (bez zmian)
      // ==================================================
      const requestFiles = await RequestModel.getFilesByRequestId(
        connection,
        id
      );
      const selectedFileIds = (validatedProject.selectedFileIds || []).map(
        String
      );

      if (requestFiles.length > 0) {
        const filesToProcess = requestFiles.filter((f) =>
          selectedFileIds.includes(String(f.id))
        );
        for (const file of filesToProcess) {
          let isCover = 0;
          if (
            validatedProject.coverSelection?.type === "existing" &&
            String(validatedProject.coverSelection.id) === String(file.id)
          ) {
            isCover = 1;
            coverSet = true;
          }
          filesToInsert.push([
            newProjectId,
            file.file_path,
            file.file_type,
            file.original_name,
            isCover,
          ]);
        }
      }

      // ==================================================
      // B. NOWE PLIKI (Upload) - MODYFIKACJA FOLDERÓW
      // ==================================================
      if (req.files) {
        // Główny folder projektu
        const baseProjectDir = path.join(
          process.cwd(),
          "uploads",
          "projects",
          String(newProjectId)
        );

        // Definicja podfolderów
        const photosDir = path.join(baseProjectDir, "photos");
        const documentsDir = path.join(baseProjectDir, "documents");

        // Tworzenie folderów (tylko jeśli są pliki danego typu)
        if (req.files["newPhotos"]?.length > 0) {
          await fs.mkdir(photosDir, { recursive: true });
        }
        if (req.files["newDocuments"]?.length > 0) {
          await fs.mkdir(documentsDir, { recursive: true });
        }

        // Mapa nazw przesłana z frontu
        const fileNameMap = validatedProject.newFileNames || {};

        // --- 1. PRZETWARZANIE ZDJĘĆ (Galeria) -> do folderu /photos ---
        const newPhotos = req.files["newPhotos"] || [];
        for (const file of newPhotos) {
          const tempId =
            file.originalname.substring(
              0,
              file.originalname.lastIndexOf(".")
            ) || file.originalname;
          const realOriginalName = fileNameMap[tempId] || file.originalname;

          let isCover = 0;
          if (
            validatedProject.coverSelection?.type === "new" &&
            validatedProject.coverSelection.id === tempId
          ) {
            isCover = 1;
            coverSet = true;
          }

          const uniqueName = `${uuidv4()}.webp`;

          // ZAPIS: Używamy photosDir
          await sharp(file.buffer)
            .resize({ width: 1200, withoutEnlargement: true })
            .webp({ quality: 80 })
            .toFile(path.join(photosDir, uniqueName));

          // BAZA: Dodajemy /photos/ do ścieżki
          const relativePath = `/uploads/projects/${newProjectId}/photos/${uniqueName}`;

          filesToInsert.push([
            newProjectId,
            relativePath,
            "photo",
            realOriginalName,
            isCover,
          ]);
        }

        // --- 2. PRZETWARZANIE DOKUMENTÓW -> do folderu /documents ---
        const newDocuments = req.files["newDocuments"] || [];
        for (const file of newDocuments) {
          const tempId =
            file.originalname.substring(
              0,
              file.originalname.lastIndexOf(".")
            ) || file.originalname;
          const realOriginalName = fileNameMap[tempId] || file.originalname;

          const isCover = 0;

          let extension = path.extname(realOriginalName);
          if (!extension) {
            if (file.mimetype === "application/pdf") extension = ".pdf";
            else if (file.mimetype.includes("image")) extension = ".jpg";
            else extension = ".bin";
          }

          const uniqueName = `${uuidv4()}${extension}`;

          // ZAPIS: Używamy documentsDir
          await fs.writeFile(path.join(documentsDir, uniqueName), file.buffer);

          // BAZA: Dodajemy /documents/ do ścieżki
          const relativePath = `/uploads/projects/${newProjectId}/documents/${uniqueName}`;

          filesToInsert.push([
            newProjectId,
            relativePath,
            "document",
            realOriginalName,
            isCover,
          ]);
        }
      }

      // C. FALLBACK OKŁADKI (bez zmian)
      if (!coverSet && filesToInsert.length > 0) {
        const firstPhotoIndex = filesToInsert.findIndex(
          (f) => f[2] === "photo"
        );
        if (firstPhotoIndex !== -1) {
          filesToInsert[firstPhotoIndex][4] = 1;
        }
      }

      // D. INSERT DO BAZY
      if (filesToInsert.length > 0) {
        await ProjectModel.addProjectFiles(connection, filesToInsert);
      }
    }

    // === UPDATE STATUS REQUESTA ===
    const updated = await RequestModel.updateStatus(connection, id, status);
    if (!updated) {
      await connection.rollback();
      return res.status(404).json({
        code: "REQUEST_NOT_FOUND",
        message: "Request not found during update",
      });
    }

    await connection.commit();
    res.status(200).json({
      code: "STATUS_UPDATED",
      message: `Request status updated to ${status}`,
      id,
      newStatus: status,
    });
  } catch (error) {
    await connection.rollback();
    console.error("Error updating request status:", error);
    res
      .status(500)
      .json({ code: "SERVER_ERROR", error: "Internal Server Error" });
  } finally {
    connection.release();
  }
};

module.exports = {
  createRequest,
  getRequests,
  getRequestDetails,
  updateRequestStatus,
};
